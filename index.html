<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>Performance Analyzer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" type="image/png" href="/assets/favicon.png">
  <link rel="stylesheet" href="/assets/main.css">
</head>

<body>
  <div id="header">
    <img src="/assets/logo.png" />
    <a class="donate" href="https://github.com/sponsors/rainerzufalldererste" target="_blank">❤️ Donate</a>
    <a class="legal" href="/impressum.html">Impressum & Datenschutz</a>
    <a class="legal" href="/compilers.html">Compiler & Dependency License information</a>
    <i class="legal" onclick="javascript:do_not_consent_to_cookies()">Revoke Cookie Consent</i>
  </div>
  <div id="app_container">
    <script src="monaco-editor/min/vs/loader.js"></script>
    <div id="code_view" class="app_view" style="width: 40%"></div>
    <script type="module">
      var code_editor;
      var last_modification = Date.now();
      const sleep_time = 2000;
      const server_url = document.location.hostname == 'localhost' ? 'http://localhost:61919/' : 'https://optim8.org/nlz/';
      var last_dump;
      var loops = [];
      var view3State = "ef";
      var last_mca;
      var cookie_consent = false;
      var loaded_with_external_data = false;

      function load_url(url, callback, obj, failure_callback) {
        var xmlhttp;

        if (window.XMLHttpRequest)
          xmlhttp = new XMLHttpRequest();
        else
          xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");

        xmlhttp.onreadystatechange = function () {
          if (xmlhttp.readyState == 4) {
            if (xmlhttp.status >= 200 && xmlhttp.status < 300) {
              try {
                let obj = JSON.parse(xmlhttp.responseText);
                callback(obj);
              } catch (e) {
                failure_callback();
              }
            } else {
              failure_callback();
            }
          }
        }

        xmlhttp.ontimeout = (e) => {
          failure_callback();
        };

        xmlhttp.timeout = 7500;
        xmlhttp.open("POST", url, true);
        xmlhttp.setRequestHeader("Content-Type", "application/json;charset=UTF-8");
        xmlhttp.send(JSON.stringify(obj));
      }

      function load_url_raw(url, callback, failure_callback) {
        var xmlhttp;

        if (window.XMLHttpRequest)
          xmlhttp = new XMLHttpRequest();
        else
          xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");

        xmlhttp.onreadystatechange = function () {
          if (xmlhttp.readyState == 4) {
            if (xmlhttp.status >= 200 && xmlhttp.status < 300) {
              try {
                callback(xmlhttp.responseText);
              } catch (e) {
                failure_callback();
              }
            } else {
              failure_callback();
            }
          }
        }

        xmlhttp.ontimeout = (e) => {
          failure_callback();
        };

        xmlhttp.timeout = 7500;
        xmlhttp.open("GET", url, true);
        xmlhttp.send();
      }

      function append_element(parent, type, className, innerText) {
        const elem = document.createElement(type);
        elem.innerText = innerText;
        elem.className = className;
        parent.appendChild(elem);
        return elem;
      }

      function hexToBytes(hex) {
        let bytes = [];

        for (let i = 0; i < hex.length; i += 3)
          bytes.push(parseInt(hex.substr(i, 2), 16));

        return bytes;
      }

      function bytesToHex(byteArray) {
        return Array.from(byteArray, function (byte) {
          return ('0' + (byte & 0xFF).toString(16)).slice(-2);
        }).join(' ');
      }

      function bytesToBase64(bytes) {
        return window.btoa(String.fromCharCode.apply(null, new Uint8Array(bytes)));
      }

      function removeChildNodesByClass(parent, className) {
        var elements = parent.getElementsByClassName(className);

        for (let i = 0; i < elements.length; i++)
          elements[i].parentElement.removeChild(elements[i]);
      }

      function register_horizontal_splitter(splitterNode) {
        var minWidth = 300;

        var leftElement = splitterNode.previousElementSibling;
        var rightElement = splitterNode.nextElementSibling;

        while (leftElement.nodeName == 'SCRIPT')
          leftElement = leftElement.previousElementSibling;

        while (rightElement.nodeName == 'SCRIPT')
          rightElement = rightElement.nextElementSibling;

        var lastX = 0;
        var isDragging = false;

        splitterNode.addEventListener('mousedown', function (e) {
          isDragging = true;
          lastX = e.clientX;
        });

        window.addEventListener('mousemove', function (e) {
          if (!isDragging)
            return;

          var deltaX = e.clientX - lastX;
          lastX = e.clientX;

          var leftWidth = parseInt(getComputedStyle(leftElement, '').width);
          var rightWidth = parseInt(getComputedStyle(rightElement, '').width);

          if (leftWidth + deltaX < minWidth || rightWidth - deltaX < minWidth)
            return;

          leftElement.style.width = (leftWidth + deltaX) + 'px';
          rightElement.style.width = (rightWidth - deltaX) + 'px';
        });

        window.addEventListener('mouseup', function () {
          isDragging = false;
        });
      }

      function register_vertical_splitter(splitterNode) {
        var minHeight = 50;

        var topElement = splitterNode.previousElementSibling;
        var bottomElement = splitterNode.nextElementSibling;

        while (topElement.nodeName == 'SCRIPT')
          topElement = topElement.previousElementSibling;

        while (bottomElement.nodeName == 'SCRIPT')
          bottomElement = bottomElement.nextElementSibling;

        var lastY = 0;
        var isDragging = false;

        splitterNode.addEventListener('mousedown', function (e) {
          isDragging = true;
          lastY = e.clientY;
        });

        window.addEventListener('mousemove', function (e) {
          if (!isDragging)
            return;

          var deltaY = e.clientY - lastY;
          lastY = e.clientY;

          var topHeight = topElement.getBoundingClientRect().height;
          var bottomHeight = bottomElement.getBoundingClientRect().height;

          if ((topHeight + deltaY < minHeight) || (bottomHeight - deltaY < minHeight))
            return;

          topElement.style.height = (topHeight + deltaY) + 'px';
          bottomElement.style.height = (bottomHeight - deltaY) + 'px';
        });

        window.addEventListener('mouseup', function () {
          isDragging = false;
        });
      }

      function handle_resize() {
        var disasm_container = document.getElementById('disasm_container');
        var self_height = disasm_container.getBoundingClientRect().height;
        var parent_bottom = disasm_container.parentElement.getBoundingClientRect().bottom;
        var next_bottom = disasm_container.nextElementSibling.nextElementSibling.getBoundingClientRect().bottom;
        var delta = parent_bottom - next_bottom;

        if (self_height + delta > 200)
          disasm_container.style.height = (self_height + delta) + 'px';

        var view3 = document.getElementById('app_view_3');
        var self_width = view3.getBoundingClientRect().width;
        var self_right = view3.getBoundingClientRect().x + self_width;
        var parent = view3.parentElement;
        var parent_right = parent.getBoundingClientRect().right;
        var delta = parent_right - self_right;

        if (self_width + delta > 200)
          view3.style.width = (self_width + delta) + 'px';

        if (view3.getBoundingClientRect().top >= parent.getBoundingClientRect().bottom) {
          var prev = view3.previousElementSibling;
          var prev_right = prev.getBoundingClientRect().x + prev.getBoundingClientRect().width;
          var delta = parent_right - prev_right - 5;

          view3.style.width = delta + 'px';
        }
      }

      window.load_from_cookies = function () {
        if (loaded_with_external_data)
          return;

        var val = localStorage.getItem('code');
        if (val != null && val != undefined)
          code_editor.setValue(val);

        val = localStorage.getItem('compiler');
        if (val != null && val != undefined)
          document.getElementById("compiler").value = val;

        val = localStorage.getItem('compiler_opt');
        if (val != null && val != undefined)
          document.getElementById("opt_lvl").value = val;

        val = localStorage.getItem('compiler_march');
        if (val != null && val != undefined)
          document.getElementById("march").value = val;

        val = localStorage.getItem('zydec_enabled');
        if (val != null && val != undefined)
          document.getElementById("zydec").checked = val;

        val = localStorage.getItem('execution_flow_march');
        if (val != null && val != undefined)
          document.getElementById("mca_arch").value = val;
      };

      window.addEventListener('load', function () {
        var separators = document.getElementsByClassName('v_separator');

        for (var i = 0; i < separators.length; i++)
          register_vertical_splitter(separators[i]);

        separators = document.getElementsByClassName('h_separator');

        for (var i = 0; i < separators.length; i++)
          register_horizontal_splitter(separators[i]);

        handle_resize();

        // load code from params.
        {
          const params = new URLSearchParams(document.location.search);
          var gistuser = params.get('gistuser');
          var hash = params.get('hash');
          var file = params.get('file');

          if (gistuser != undefined && hash != undefined && file != undefined) {
            load_url_raw('https://gist.githubusercontent.com/' + gistuser + '/' + hash + '/raw/' + file, (e) => {
              loaded_with_external_data = true;
              code_editor.setValue(e);
            }, () => { alert('Failed to load gist file.'); });
          }

          var val = params.get('compiler');
          if (val != null && val != undefined)
            document.getElementById("compiler").value = val.replaceAll('clang  ', 'clang++').replaceAll('g  ', 'g++');

          val = params.get('opt');
          if (val != null && val != undefined)
            document.getElementById("opt_lvl").value = val;

          val = params.get('march');
          if (val != null && val != undefined)
            document.getElementById("march").value = val;

          val = params.get('zydec');
          if (val != null && val != undefined)
            document.getElementById("zydec").checked = val;

          val = params.get('mca_arch');
          if (val != null && val != undefined)
            document.getElementById("mca_arch").value = val;
        }

        if (localStorage.getItem('cookie_consent') != undefined && localStorage.getItem('cookie_consent') != null)
          cookie_consent = true;

        if (cookie_consent)
          window.load_from_cookies();
        else
          document.getElementById('cookie_consent_banner').style.display = 'block';
      });

      window.addEventListener('resize', () => {
        handle_resize();
      });

      function loadScript(url, callback) {
        var script = document.createElement("script");
        script.type = "text/javascript";

        if (script.readyState) {
          script.onreadystatechange = function () {
            if (script.readyState === "loaded" || script.readyState === "complete") {
              script.onreadystatechange = null;
              callback();
            }
          };
        } else {
          script.onload = function () {
            callback();
          };
        }

        script.src = url;
        document.getElementsByTagName("head")[0].appendChild(script);
      }

      function xmlToJson(xml) {
        var obj = {};

        if (xml.nodeType == 1) {
          if (xml.attributes.length > 0) {
            obj["@attributes"] = {};
            for (var j = 0; j < xml.attributes.length; j++) {
              var attribute = xml.attributes.item(j);
              obj["@attributes"][attribute.nodeName] = attribute.nodeValue;
            }
          }
        } else if (xml.nodeType == 3) {
          obj = xml.nodeValue;
        }

        if (xml.hasChildNodes()) {
          for (var i = 0; i < xml.childNodes.length; i++) {
            var item = xml.childNodes.item(i);
            var nodeName = item.nodeName;
            if (typeof (obj[nodeName]) == "undefined") {
              obj[nodeName] = xmlToJson(item);
            } else {
              if (typeof (obj[nodeName].push) == "undefined") {
                var old = obj[nodeName];
                obj[nodeName] = [];
                obj[nodeName].push(old);
              }
              obj[nodeName].push(xmlToJson(item));
            }
          }
        }
        return obj;
      };

      var iig_loaded = false;
      var iig_loading = false;
      var iig;
      var iig_last_search = "";

      window.search_iig = function (query) {
        iig_last_search = query;

        if (!iig_loaded && !iig_loading) {
          iig_loading = true;
          loadScript('/assets/data.js', () => {
            const parser = new DOMParser();
            const doc = parser.parseFromString(data_js, "application/xml");

            iig = xmlToJson(doc);
            iig_loaded = true;

            search_iig(iig_last_search);
          });
        }

        if (!iig_loaded)
          return;

        var results = document.getElementById('iig_results');
        results.innerHTML = '';

        var qs = query.split(' ');
        var matches = [];

        for (let j = 0; j < iig.intrinsics_list.intrinsic.length; j++) {
          let i = iig.intrinsics_list.intrinsic[j];

          var match_quality = 0;

          for (let k = 0; k < qs.length; k++) {
            let q = qs[k].toLowerCase().trim();

            if (q.length == 0)
              continue;

            if (i.description['#text'].toLowerCase().includes(q))
              match_quality += 1;

            if (i['@attributes'].name.toLowerCase().includes(q))
              match_quality += 4;

            if (i.instruction != undefined) {
              if (i.instruction.length == 0 || i.instruction.length == undefined) {
                if (i.instruction['@attributes'].name.toLowerCase().includes(q))
                  match_quality += 1;
              } else {
                for (let l = 0; l < i.instruction.length; l++)
                  if (i.instruction[l]['@attributes'].name.toLowerCase().includes(q))
                    match_quality += 1;
              }
            }

            if (i.CPUID != undefined) {
              if (i.CPUID.length == undefined || i.CPUID.length == 0) {
                if (i.CPUID['#text'].toLowerCase() === q)
                  match_quality += 10;
              } else {
                for (let l = 0; l < i.CPUID.length; l++)
                  if (i.CPUID[l]['#text'].toLowerCase() === q)
                    match_quality += 10;
              }
            }
            else if (i['@attributes'].tech.toLowerCase() === q) {
              match_quality += 10;
            }
          }

          if (match_quality > 0) {
            let instructions = [];
            let params = [];
            let op = "";
            let tech = i['@attributes'].tech;

            if (i.CPUID != undefined) {
              if (i.CPUID.length == undefined || i.CPUID.length == 0) {
                tech = i.CPUID['#text'];
              } else {
                for (let l = 0; l < i.CPUID.length; l++) {
                  if (l == 0)
                    tech = '';
                  else
                    tech += ' / ';

                  tech += i.CPUID[l]['#text'];
                }
              }
            }

            if (i.operation != undefined)
              op = i.operation['#text'].trim().trim('\n');

            if (i.parameter != undefined) {
              if (i.parameter.length != undefined && i.parameter.length != 0) {
                for (let l = 0; l < i.parameter.length; l++)
                  params.push({ 'type': i.parameter[l]['@attributes'].type, 'name': i.parameter[l]['@attributes'].varname });
              } else {
                params.push({ 'type': i.parameter['@attributes'].type, 'name': i.parameter['@attributes'].varname });
              }
            }

            if (i.instruction != undefined) {
              if (i.instruction.length != undefined && i.instruction.length != 0) {
                for (let l = 0; l < i.instruction.length; l++)
                  instructions.push(i.instruction[l]['@attributes'].name + ' ' + i.instruction[l]['@attributes'].form);
              } else {
                instructions.push(i.instruction['@attributes'].name + ' ' + i.instruction['@attributes'].form);
              }
            }

            matches.push({ 'quality': match_quality, 'ret': i.return['@attributes'].type, 'intrin': i['@attributes'].name, 'params': params, 'instructions': instructions, 'desc': i.description['#text'], 'tech': tech, 'op': op });
          }
        }

        matches.sort((a, b) => (a.quality < b.quality) ? 1 : -1);

        for (let j = 0; j < matches.length && j < 100; j++) {
          let i = matches[j];

          var container = append_element(results, 'div', 'iig_result_container', '');
          var header = append_element(container, 'div', 'iig_header', '');
          var body = append_element(container, 'div', 'iig_body', '');

          header.style.setProperty('--relevance', i.quality);

          append_element(header, 'b', 'iig_type', i.ret);
          append_element(header, 'b', 'iig_name', i.intrin);
          append_element(header, 'i', 'iig_misc', '(');

          (() => {
            var c = container;
            header.onclick = () => {
              if (c.className.includes(' selected'))
                c.className = c.className.replaceAll(' selected', '');
              else
                c.className += ' selected';
            };
          })();

          for (let k = 0; k < i.params.length; k++) {
            if (k > 0)
              append_element(header, 'i', 'iig_misc', ', ');

            append_element(header, 'b', 'iig_type', i.params[k].type);
            append_element(header, 'b', 'iig_name param', i.params[k].name);
          }

          append_element(header, 'i', 'iig_misc', ')');
          append_element(header, 'b', 'iig_tech ' + i.tech.replaceAll(' / ', ' '), i.tech);

          append_element(body, 'div', 'iig_desc', i.desc)
          append_element(body, 'div', 'iig_op', i.op)

          for (let k = 0; k < i.instructions.length; k++)
            append_element(body, 'div', 'iig_instruction', i.instructions[k]);
        }
      }

      function error_execution_flow() {
        let stats = document.getElementById('analysis');
        stats.style.display = 'none';

        let flow = document.getElementById('execution_flow');
        flow.style.display = 'inherit';
        flow.innerHTML = "";

        append_element(flow, 'div', 'error exec_flow', '');
      }

      var last_execution_flow_loop_idx = -1;

      function offer_redraw_execution_flow() {
        if (last_mca == null)
          return;

        try {
          draw_execution_flow();
        } catch (e) {
          error_execution_flow();
        }
      }

      function draw_execution_flow() {
        const e = last_mca;

        for (let i = 0; i < last_dump.length; i++) {
          let func = last_dump[i];

          for (let j = 0; j < func.length; j++) {
            func[j].element.className = func[j].element.className.replaceAll(' matched', '');
            removeChildNodesByClass(func[j].element, 'dependency');
            removeChildNodesByClass(func[j].element, 'mca_info');
          }
        }

        let stats = document.getElementById('analysis');
        stats.style.display = 'inherit';
        stats.innerHTML = "";

        append_element(stats, 'h3', 'stats_headline', 'Across ' + e.stats.iterations + ' Iterations:');
        append_element(stats, 'p', 'stat', '~' + e.stats.cycles + ' Cycles / Iteration (dispatched -> retired)');
        append_element(stats, 'p', 'stat', '~' + e.stats.execution_cycles + ' Cycles / Iteration (issued -> executed)');

        append_element(stats, 'p', 'stat specific', 'Dispatched: ' + e.stats.dispatched + ' Cycles');
        append_element(stats, 'p', 'stat specific', 'Pending: ' + e.stats.pending + ' Cycles');
        append_element(stats, 'p', 'stat specific', 'Ready: ' + e.stats.ready + ' Cycles');
        append_element(stats, 'p', 'stat specific', 'Executing: ' + e.stats.executing + ' Cycles');
        append_element(stats, 'p', 'stat specific', 'Retiring: ' + e.stats.retiring + ' Cycles');

        let flow = document.getElementById('execution_flow');
        flow.style.display = 'inherit';
        flow.innerHTML = "";

        let headline_row = append_element(flow, "tr", "", "");
        let usage_row = append_element(flow, "tr", "", "");
        let flow_row = append_element(flow, "tr", "exec_flow_tr", "");

        let flow_lanes = [];

        for (let i = 0; i < e.ports.length; i++) {
          append_element(headline_row, "th", "mca", e.ports[i]);
          append_element(usage_row, "td", "mca_th_stats", (e.stats.ports[i] * 100.0).toFixed(0)).style.setProperty('--usage', e.stats.ports[i]);

          var lane = append_element(flow_row, "td", "flow_lane", "");
          flow_lanes.push(lane);
        }

        append_element(flow_lanes[0], "div", "exec_flow_spacing", "").style.setProperty('--position', e.stats.cycles_total);

        let func_idx = 0;
        let instruction_idx = 0;

        for (let i = 0; i < e.instructions.length; i++) {
          let inst = e.instructions[i];

          let lanes = [];

          for (let k = 0; k < inst.iterations.length; k++) {
            let iter = inst.iterations[k];

            if (iter.ports == undefined || iter.ports.length == 0)
              continue;

            for (let j = 0; j < iter.ports.length; j++) {
              let lane_idx = iter.ports[j];
              let lane = append_element(flow_lanes[lane_idx], 'div', 'lane', '');
              lane.style.setProperty('--start', iter.issued);
              lane.style.setProperty('--length', iter.executed - iter.issued);
              lane.style.setProperty('--iteration', k);
              lane.style.setProperty('--lane', lane_idx);
              lanes.push(lane);
            }
          }

          // Connect with displayed instruction.
          let matched_inst = null;

          while (func_idx < last_dump.length) {
            if (last_dump[func_idx].length <= instruction_idx) {
              instruction_idx = 0;
              func_idx++;
              continue;
            }
            else {
              if (last_dump[func_idx][instruction_idx].addr == inst.addr) {
                matched_inst = last_dump[func_idx][instruction_idx];
                break;
              }

              instruction_idx++;
            }
          }

          if (matched_inst == null)
            continue;

          inst.lanes = lanes;
          matched_inst.flow = inst;
          matched_inst.element.className += " matched";
          let addr = matched_inst.element.childNodes[0];
          addr.style.setProperty('--weight', inst.executing);

          var info = append_element(addr, 'div', 'mca_info', '');
          append_element(info, 'b', 'mca_istat', 'uOps: ' + inst.uops);
          append_element(info, 'b', 'mca_istat', 'dispatched: ~' + inst.dispatched + ' cycle(s) / iteration');
          append_element(info, 'b', 'mca_istat', 'pending: ~' + inst.pending + ' cycle(s) / iteration');
          append_element(info, 'b', 'mca_istat', 'ready: ~' + inst.ready + ' cycle(s) / iteration');
          append_element(info, 'b', 'mca_istat', 'executing: ~' + inst.executing + ' cycle(s) / iteration');
          append_element(info, 'b', 'mca_istat', 'retiring: ~' + inst.retiring + ' cycle(s) / iteration');

          if (inst.stalls != undefined)
            for (let j = 0; j < inst.stalls.length; j++)
              append_element(info, 'b', 'mca_stall', inst.stalls[j]);

          if (inst.pressure != undefined) {
            for (let j = 0; j < inst.pressure.length; j++) {
              let p = inst.pressure[j];

              var pressure = append_element(addr, 'div', 'dependency ' + p.type + (p.origin_offset > 0 ? ' below' : ' above'), '');
              pressure.style.setProperty('--offset', Math.abs(p.origin_offset));

              var pr = append_element(info, 'i', 'mca_pressure ' + p.type, p.cycles + ' cycle(s) on ');

              if (p.type == 'reg')
                append_element(pr, 'b', 'mca_reg', p.name);
              else if (p.type == 'mem')
                append_element(pr, 'i', 'mca_nondescript', 'memory');
              else if (p.type == 'rsrc')
                append_element(pr, 'b', 'mca_port', p.port_name);

              append_element(pr, 'i', 'mca_nondescript', ' in ');
              append_element(pr, 'b', 'mca_loop', p.it);

              if (p.it != p.origin_it)
                append_element(pr, 'b', 'mca_loop_origin', p.origin_it);
            }
          }

          (() => {
            let minstr = matched_inst;
            var decorationHandle;

            minstr.element.onmouseenter = () => {
              minstr.element.className += " selected";

              for (let k = 0; k < minstr.flow.lanes.length; k++) {
                let lane = minstr.flow.lanes[k];
                lane.className += " selected";
              }

              if (minstr.line != null) {
                if (decorationHandle != null)
                  code_editor.deltaDecorations(decorationHandle, []);

                decorationHandle = code_editor.deltaDecorations([], [{ range: new monaco.Range(minstr.line, 1, minstr.line, 1), options: { isWholeLine: true, className: 'monaco_line_highlighted' } }]);
              }
            };

            minstr.element.onmouseleave = () => {
              minstr.element.className = minstr.element.className.replaceAll(" selected", "");

              for (let k = 0; k < minstr.flow.lanes.length; k++) {
                let lane = minstr.flow.lanes[k];
                lane.className = lane.className.replaceAll(" selected", "");
              }

              if (decorationHandle != null)
                code_editor.deltaDecorations(decorationHandle, []);

              decorationHandle = null;
            };

            for (let j = 0; j < lanes.length; j++) {
              lanes[j].onmouseenter = () => {
                minstr.element.className += " selected";

                for (let k = 0; k < minstr.flow.lanes.length; k++) {
                  let lane = minstr.flow.lanes[k];
                  lane.className += " selected";
                }

                if (minstr.line != null) {
                  if (decorationHandle != null)
                    code_editor.deltaDecorations(decorationHandle, []);

                  decorationHandle = code_editor.deltaDecorations([], [{ range: new monaco.Range(minstr.line, 1, minstr.line, 1), options: { isWholeLine: true, className: 'monaco_line_highlighted' } }]);
                }
              };

              lanes[j].onmouseleave = () => {
                minstr.element.className = minstr.element.className.replaceAll(" selected", "");

                for (let k = 0; k < minstr.flow.lanes.length; k++) {
                  let lane = minstr.flow.lanes[k];
                  lane.className = lane.className.replaceAll(" selected", "");
                }

                if (decorationHandle != null)
                  code_editor.deltaDecorations(decorationHandle, []);

                decorationHandle = null;
              };
            }
          })();
        }
      }

      function suggest_execution_flow(loop_idx) {
        last_execution_flow_loop_idx = loop_idx;

        if (view3State != 'ef')
          return;

        let bytes = [];

        const start = loops[loop_idx].start;
        const end = loops[loop_idx].end;

        for (let i = 0; i < last_dump.length; i++) {
          let func = last_dump[i];

          for (let j = 0; j < func.length; j++) {
            let x = func[j];

            if (x.addr >= start && x.addr < end)
              bytes = bytes.concat(x.bytes);
          }
        }

        const base64 = bytesToBase64(bytes);
        const arch = document.getElementById("mca_arch").value;
        const request = { 'bytes': base64, 'addr': start, 'march': arch };

        let stats = document.getElementById('analysis');
        stats.style.display = 'none';

        let flow = document.getElementById('execution_flow');
        flow.style.display = 'inherit';
        flow.innerHTML = "";

        last_mca = null;
        append_element(flow, 'div', 'spinner', '');

        (() => {
          let loop_index = loop_idx;

          load_url(server_url + 'execution_flow', (e) => {
            last_mca = e;

            draw_execution_flow();
          }, request, () => {
            error_execution_flow();
          });
        })();
      }

      function error_zydec() {
        let zydec_spinner = document.getElementById('zydec_spinner');
        if (zydec_spinner != null && zydec_spinner != undefined)
          zydec_spinner.parentElement.removeChild(zydec_spinner);

        let disasm_spinner = document.getElementById('disasm_spinner');
        if (disasm_spinner != null && disasm_spinner != undefined)
          disasm_spinner.parentElement.removeChild(disasm_spinner);

        let disasm_error = document.getElementById('disasm_error');
        if (disasm_error != null && disasm_error != undefined)
          disasm_error.parentElement.removeChild(disasm_error);

        let zydec_error = document.getElementById('zydec_error');
        if (zydec_error == null || zydec_error == undefined)
          append_element(document.getElementById('asm'), 'div', 'error zydec', '').id = 'zydec_error';
      }

      function display_zydec() {
        let zydec_spinner = document.getElementById('zydec_spinner');
        if (zydec_spinner != null && zydec_spinner != undefined)
          zydec_spinner.parentElement.removeChild(zydec_spinner);

        let zydec_error = document.getElementById('zydec_error');
        if (zydec_error != null && zydec_error != undefined)
          zydec_error.parentElement.removeChild(zydec_error);

        let disasm_spinner = document.getElementById('disasm_spinner');
        if (disasm_spinner != null && disasm_spinner != undefined)
          disasm_spinner.parentElement.removeChild(disasm_spinner);

        let disasm_error = document.getElementById('disasm_error');
        if (disasm_error != null && disasm_error != undefined)
          disasm_error.parentElement.removeChild(disasm_error);

        for (let i = 0; i < last_dump.length; i++) {
          let sym = last_dump[i];

          for (let j = 0; j < sym.length; j++) {
            let data = sym[j];
            let n = data.element;
            n.innerHTML = "";

            let sect = data.dec.split('// ');

            var addr = append_element(n, 'b', 'addr dec', data.addrStr);
            append_element(n, 'i', 'bytes', bytesToHex(data.bytes));

            var dec = append_element(n, 'b', 'dec', sect[0]);

            dec.innerHTML = dec.innerHTML.replaceAll('(m512)', '<i class="dectype">m512</i>');
            dec.innerHTML = dec.innerHTML.replaceAll('(m256)', '<i class="dectype">m256</i>');
            dec.innerHTML = dec.innerHTML.replaceAll('(m128)', '<i class="dectype">m128</i>');
            dec.innerHTML = dec.innerHTML.replaceAll('(i64)', '<i class="dectype">i64</i>');
            dec.innerHTML = dec.innerHTML.replaceAll('(i32)', '<i class="dectype">i32</i>');
            dec.innerHTML = dec.innerHTML.replaceAll('(i16)', '<i class="dectype">i16</i>');
            dec.innerHTML = dec.innerHTML.replaceAll('(i8)', '<i class="dectype">i8</i>');

            dec.innerHTML = dec.innerHTML.replaceAll('extra_segment:', '<i class="decbuiltin">extra_segment:</i>');
            dec.innerHTML = dec.innerHTML.replaceAll('code_segment:', '<i class="decbuiltin">code_segment:</i>');
            dec.innerHTML = dec.innerHTML.replaceAll('stack_segment:', '<i class="decbuiltin">stack_segment:</i>');
            dec.innerHTML = dec.innerHTML.replaceAll('data_segment:', '<i class="decbuiltin">data_segment:</i>');
            dec.innerHTML = dec.innerHTML.replaceAll('f_segment:', '<i class="decbuiltin">f_segment:</i>');
            dec.innerHTML = dec.innerHTML.replaceAll('g_segment:', '<i class="decbuiltin">g_segment:</i>');

            dec.innerHTML = dec.innerHTML.replaceAll('carry_flag', '<i class="decbuiltin">carry_flag</i>');
            dec.innerHTML = dec.innerHTML.replaceAll('zero_flag', '<i class="decbuiltin">zero_flag</i>');
            dec.innerHTML = dec.innerHTML.replaceAll('sign_flag', '<i class="decbuiltin">sign_flag</i>');
            dec.innerHTML = dec.innerHTML.replaceAll('overflow_flag', '<i class="decbuiltin">overflow_flag</i>');
            dec.innerHTML = dec.innerHTML.replaceAll('parity_flag', '<i class="decbuiltin">parity_flag</i>');

            dec.innerHTML = dec.innerHTML.replaceAll('compare(', '<i class="decbasic">compare</i>(');
            dec.innerHTML = dec.innerHTML.replaceAll('if (', '<i class="decbasic">if</i> (');
            dec.innerHTML = dec.innerHTML.replaceAll('goto ', '<i class="decbasic">goto</i> ');
            dec.innerHTML = dec.innerHTML.replaceAll('return;', '<i class="decbasic">return</i>;');

            if (sect.length > 1)
              append_element(n, 'b', 'comment dec', "// " + sect[1]);

            append_element(n, 'i', 'isa ' + data.isa, data.isa);
            append_element(n, 'br', 'hidden', '');

            if (data.isJump) {
              for (let k = 0; k < sym.length; k++) {
                let target = sym[k];

                if (target.addr != data.target)
                  continue;

                append_element(addr, 'div', "jmp " + (target.addr < data.addr ? "above" : "below"), "").style.setProperty('--offset', Math.abs(k - j));

                break;
              }
            }
          }
        }

        offer_redraw_execution_flow();
      }

      function load_zydec(dump_index) {
        let zydec_spinner = document.getElementById('zydec_spinner');
        if (zydec_spinner == null || zydec_spinner == undefined)
          append_element(document.getElementById('asm'), 'div', 'spinner zydec', '').id = 'zydec_spinner';

        let bytes = [];
        let func = last_dump[dump_index];

        for (let i = 0; i < func.length; i++)
          bytes = bytes.concat(func[i].bytes);

        const base64 = bytesToBase64(bytes);
        const request = { 'bytes': base64, 'addr': func[0].addr };

        (() => {
          let dump_idx = dump_index;

          load_url(server_url + 'zydec', (e) => {
            let func = last_dump[dump_idx];
            let idx = 0;
            let data = e.zydec.split('\n');

            for (let i = 0; i < data.length; i++) {
              if (data[i] == '')
                continue;

              let sect = data[i].split('\t');
              let addr = parseInt(sect[0]);

              let n = func[idx];

              if (n.addr == addr) {
                idx++;

                n.rawZydec = data[i];
                n.dec = sect[1];
                n.isa = sect[2];
              }
            }

            if (last_dump.length > dump_idx + 1) {
              load_zydec(dump_idx + 1);
            }
            else {
              last_dump['zydec'] = true;
              display_zydec();
            }
          }, request, () => {
            error_zydec();
          });
        })();
      }

      function try_display_zydec() {
        try {
          if (last_dump['zydec'] == true)
            display_zydec();
          else
            load_zydec(0);
        } catch (e) {
          error_zydec();
        }
      }

      function display_disasm() {
        let zydec_spinner = document.getElementById('zydec_spinner');
        if (zydec_spinner != null && zydec_spinner != undefined)
          zydec_spinner.parentElement.removeChild(zydec_spinner);

        let zydec_error = document.getElementById('zydec_error');
        if (zydec_error != null && zydec_error != undefined)
          zydec_error.parentElement.removeChild(zydec_error);

        let disasm_spinner = document.getElementById('disasm_spinner');
        if (disasm_spinner != null && disasm_spinner != undefined)
          disasm_spinner.parentElement.removeChild(disasm_spinner);

        let disasm_error = document.getElementById('disasm_error');
        if (disasm_error != null && disasm_error != undefined)
          disasm_error.parentElement.removeChild(disasm_error);

        var asm = document.getElementById('asm');
        asm.innerHTML = "";

        for (let i = 0; i < last_dump.length; i++) {
          let sym = last_dump[i];

          var container = append_element(asm, 'div', 'function', '');
          sym.element = append_element(container, 'h3', 'symbol', sym.name);

          for (let j = 0; j < sym.length; j++) {
            let instruction = sym[j];

            var e = append_element(container, 'p', 'asm_line', '');
            e.origin = { 'sym': i, 'line': j, 'addr': instruction.addr };
            instruction.element = e;
            var addr = append_element(e, 'b', 'addr', instruction.addrStr);
            append_element(e, 'i', 'bytes', bytesToHex(instruction.bytes));
            append_element(e, 'b', instruction.isJump ? 'jump' : 'mnemonic', instruction.mnemonic);
            var params = append_element(e, 'i', 'params', instruction.params);
            params.innerHTML = params.innerHTML.replaceAll('ZMMWORD PTR ', '<i class="ptr">ZMMWORD  PTR </i> ');
            params.innerHTML = params.innerHTML.replaceAll('YMMWORD PTR ', '<i class="ptr">YMMWORD  PTR </i> ');
            params.innerHTML = params.innerHTML.replaceAll('XMMWORD PTR ', '<i class="ptr">XMMWORD  PTR </i> ');
            params.innerHTML = params.innerHTML.replaceAll('QWORD PTR ', '<i class="ptr">QWORD  PTR </i> ');
            params.innerHTML = params.innerHTML.replaceAll('DWORD PTR ', '<i class="ptr">DWORD  PTR </i> ');
            params.innerHTML = params.innerHTML.replaceAll('WORD PTR ', '<i class="ptr">WORD  PTR </i> ');
            params.innerHTML = params.innerHTML.replaceAll('BYTE PTR ', '<i class="ptr">BYTE  PTR </i> ');

            if (instruction.comment)
              append_element(e, 'i', 'comment', instruction.comment);

            if (instruction.isJump) {
              for (let k = 0; k < sym.length; k++) {
                let target = sym[k];

                if (target.addr != instruction.target)
                  continue;

                append_element(addr, 'div', "jmp " + (target.addr < instruction.addr ? "above" : "below"), "").style.setProperty('--offset', Math.abs(k - j));

                break;
              }
            }

            (() => {
              let minstr = instruction;
              var decorationHandle;

              minstr.element.onmouseenter = () => {
                minstr.element.className += " selected";

                if (minstr.line != null) {
                  if (decorationHandle != null)
                    code_editor.deltaDecorations(decorationHandle, []);

                  decorationHandle = code_editor.deltaDecorations([], [{ range: new monaco.Range(minstr.line, 1, minstr.line, 1), options: { isWholeLine: true, className: 'monaco_line_highlighted' } }]);
                }
              };

              minstr.element.onmouseleave = () => {
                minstr.element.className = minstr.element.className.replaceAll(" selected", "");

                if (decorationHandle != null)
                  code_editor.deltaDecorations(decorationHandle, []);

                decorationHandle = null;
              };
            })();
          }
        }

        append_element(asm, 'div', 'asm_spacing', '');
        offer_redraw_execution_flow();
      }

      function error_disasm() {
        let zydec_spinner = document.getElementById('zydec_spinner');
        if (zydec_spinner != null && zydec_spinner != undefined)
          zydec_spinner.parentElement.removeChild(zydec_spinner);

        let zydec_error = document.getElementById('zydec_error');
        if (zydec_error != null && zydec_error != undefined)
          zydec_error.parentElement.removeChild(zydec_error);

        let disasm_spinner = document.getElementById('disasm_spinner');
        if (disasm_spinner != null && disasm_spinner != undefined)
          disasm_spinner.parentElement.removeChild(disasm_spinner);

        let disasm_error = document.getElementById('disasm_error');
        if (disasm_error == null || disasm_error == undefined)
          append_element(document.getElementById('asm'), 'div', 'error disasm', '').id = 'disasm_error';
      }

      function suggest_compile() {
        if ((Date.now() - last_modification) >= sleep_time - 2) {
          last_dump = null;
          loops = [];

          document.getElementById('analysis_selector').style.display = "hidden";
          document.getElementById('analysis').style.display = "hidden";
          document.getElementById('execution_flow').style.display = "hidden";

          last_execution_flow_loop_idx = -1;
          last_modification = Date.now();

          var compiler = document.getElementById("compiler").value;
          var opt = document.getElementById("opt_lvl").value;
          var march = document.getElementById("march").value;

          load_url(server_url + compiler, (e) => {
            var compiler_out = e['compiler'];
            var objdump_out = e['objdump'];
            var stdout = document.getElementById('stdout');

            if (compiler_out == '')
              compiler_out = "Success!";

            stdout.innerText = compiler_out;
            stdout.innerHTML = stdout.innerHTML.replaceAll(' ', '&ensp;');
            var dumplines = objdump_out.split('\n');
            last_dump = [];
            var last_sym = [];
            var expect_symbol = true;
            var lastLine = null;
            const jumps = ['jmp', 'ja', 'jae', 'jb', 'jbe', 'jc', 'jcxz', 'jrcxz', 'je', 'jecxz', 'jg', 'jge', 'jl', 'jle', 'jna', 'jnae', 'jnb', 'jnbe', 'jnc', 'jne', 'jnbe', 'jng', 'jnge', 'jnl', 'jnle', 'jno', 'jnp', 'jns', 'jnz', 'jo', 'jp', 'jpe', 'jpo', 'js', 'jz'];

            let addressOffset = 0;
            let maxAddress = 0;

            for (let i = 0; i < dumplines.length; i++) {
              let x = dumplines[i];

              if (x == '') {
                expect_symbol = true;
              } else if (expect_symbol) {
                let reused = false;

                if (x.startsWith('Disassembly of section')) {
                  addressOffset = maxAddress + 32;
                  addressOffset &= ~(15);
                  reused = true;
                }
                
                expect_symbol = false;

                if (last_sym.length != 0) {
                  last_sym = [];
                  reused = true;
                }

                var prefix = x.split('<')[0];
                last_sym.name = x.substring(prefix.length);

                if (!reused)
                  last_dump.push(last_sym);
              } else {
                const trimmed = x.trim();
                const sect = x.split('\t');

                if (sect.length == 1) { // function start.
                  lastLine = null;
                  var colonSect = sect[0].split(':');

                  if (colonSect.length == 1 || colonSect[1].length == 0)
                    continue;

                  if (colonSect[0].endsWith('.cpp')) {
                    var filenameParts = colonSect[0].split('/');
                    var lastPart = filenameParts[filenameParts.length - 1];
                    var possibleNum = lastPart.substring(0, lastPart.length - 4); // remove '.cpp'
                    var asInt = parseInt(possibleNum);

                    if (asInt.toString() == possibleNum)
                      lastLine = parseInt(colonSect[1]);
                    else
                      lastLine = null;
                  }
                  else {
                    lastLine = null;
                  }
                } else {
                  const addrStr = sect[0].replaceAll(':', '').trim(' ');
                  
                  const addr = parseInt(addrStr, 16) + addressOffset;
                  maxAddress = Math.max(maxAddress, addr);

                  const hex = sect[1].trim(' ');
                  const bytes = hexToBytes(hex);
                  const _asm = sect[2].trim(' ').replaceAll(',', ", ").replaceAll('  ', ' ');
                  const mnemonic = _asm.split(' ')[0];
                  const params = _asm.substring(mnemonic.length).trim();
                  const beforeComment = params.split('#')[0];
                  const comment = params.substring(beforeComment.length);
                  const isJump = jumps.includes(mnemonic);
                  var target;

                  if (isJump) {
                    var targetStr = beforeComment.split(' ')[0];
                    target = parseInt(targetStr, 16) + addressOffset;

                    if (target < addr)
                      loops.push({ 'start': target, 'end': addr + bytes.length - 1, 'offset': addressOffset, 'symbol': last_sym.name });
                  }

                  last_sym.push({ 'raw': x, 'addrStr': addrStr, 'addr': addr, 'bytes': bytes, 'asm': _asm, 'mnemonic': mnemonic, 'params': beforeComment, 'comment': comment, 'isJump': isJump, 'target': target, line: lastLine });
                }
              }
            }

            last_mca = null;

            let stats = document.getElementById('analysis');
            stats.style.display = 'none';

            let flow = document.getElementById('execution_flow');
            flow.style.display = 'none';
            flow.innerHTML = "";

            var loop_selector = document.getElementById('analysis_selector');
            loop_selector.innerHTML = "Select Region to Analyze<br/>";

            if (loops.length == 0) {
              loop_selector.innerHTML = "No looping Regions found!";
            } else if (loops.length == 1) {
              loop_selector.style.display = "none";

              suggest_execution_flow(0);
            } else {
              loop_selector.style.display = "inherit";

              for (let i = 0; i < loops.length; i++) {
                let e = append_element(loop_selector, 'div', 'loop_selection', (loops[i].start - loops[i].offset).toString(16) + " - " + (loops[i].end - loops[i].offset).toString(16) + " (" + (loops[i].end - loops[i].start).toString(16) + ")");
                e.title = loops[i].symbol;

                (function () {
                  let e_ = e;
                  let idx = i;
                  var decorationHandle;

                  e_.onclick = () => {
                    suggest_execution_flow(idx);
                  };

                  e_.onmouseenter = () => {
                    const start = loops[idx].start;
                    const end = loops[idx].end;
                    let decorations = [];

                    for (let j = 0; j < last_dump.length; j++) {
                      let func = last_dump[j];

                      for (let k = 0; k < func.length; k++) {
                        let x = func[k];

                        if (x.addr >= start && x.addr < end) {
                          x.element.className += " hover";

                          if (x.line != null)
                            decorations.push({ range: new monaco.Range(x.line, 1, x.line, 1), options: { isWholeLine: true, className: 'monaco_line_highlighted' } });
                        }
                      }
                    }

                    decorationHandle = code_editor.deltaDecorations([], decorations);
                  };

                  e_.onmouseleave = () => {
                    const start = loops[idx].start;
                    const end = loops[idx].end;

                    for (let j = 0; j < last_dump.length; j++) {
                      let func = last_dump[j];

                      for (let k = 0; k < func.length; k++) {
                        let x = func[k];

                        if (x.addr >= start && x.addr < end)
                          x.element.className = x.element.className.replaceAll(" hover", "");
                      }
                    }

                    code_editor.deltaDecorations(decorationHandle, []);
                  };
                })();
              }
            }

            display_disasm();

            if (document.getElementById('zydec').checked)
              load_zydec(0);

          }, { 'opt': opt, 'march': march, 'src': code_editor.getValue() }, () => {
            error_disasm();
          });
        }
      }

      window.content_changed = function () {
        document.getElementById('stdout').innerText = "Waiting for Compile...";
        last_modification = Date.now();
        setTimeout(suggest_compile, sleep_time);

        if (cookie_consent && !loaded_with_external_data) {
          localStorage.setItem('code', code_editor.getValue());
          localStorage.setItem('compiler', document.getElementById("compiler").value);
          localStorage.setItem('compiler_opt', document.getElementById("opt_lvl").value);
          localStorage.setItem('compiler_march', document.getElementById("march").value);
        }

        let zydec_spinner = document.getElementById('zydec_spinner');
        if (zydec_spinner != null && zydec_spinner != undefined)
          zydec_spinner.parentElement.removeChild(zydec_spinner);

        let zydec_error = document.getElementById('zydec_error');
        if (zydec_error != null && zydec_error != undefined)
          zydec_error.parentElement.removeChild(zydec_error);

        let disasm_spinner = document.getElementById('disasm_spinner');
        if (disasm_spinner != null && disasm_spinner != undefined)
          disasm_spinner.parentElement.removeChild(disasm_spinner);

        let disasm_error = document.getElementById('disasm_error');
        if (disasm_error != null && disasm_error != undefined)
          disasm_error.parentElement.removeChild(disasm_error);

        append_element(document.getElementById('asm'), 'div', 'spinner disasm', '').id = 'disasm_spinner';
      }

      window.zydec_changed = function () {
        if (document.getElementById('zydec').checked) {
          try_display_zydec();
        } else {
          try {
            display_disasm();
          } catch (e) {
            error_disasm();
          }
        }

        if (cookie_consent && !loaded_with_external_data)
          localStorage.setItem('zydec_enabled', document.getElementById("zydec").checked);
      }

      window.mca_changed = function () {
        if (last_execution_flow_loop_idx >= 0)
          suggest_execution_flow(last_execution_flow_loop_idx);

        if (cookie_consent && !loaded_with_external_data)
          localStorage.setItem('execution_flow_march', document.getElementById("mca_arch").value);
      }

      window.switch_to_flow = function () {
        var flow = document.getElementById('tab_flow');
        var iig = document.getElementById('tab_iig');

        flow.className += ' active';
        iig.className = iig.className.replaceAll(' active', '');

        flow = document.getElementById('execution_flow_container');
        iig = document.getElementById('documentation');

        flow.style.display = 'inherit';
        iig.style.display = 'none';

        view3State = 'ef';
        offer_redraw_execution_flow();
      }

      window.switch_to_iig = function () {
        var flow = document.getElementById('tab_flow');
        var iig = document.getElementById('tab_iig');

        iig.className += ' active';
        flow.className = flow.className.replaceAll(' active', '');

        flow = document.getElementById('execution_flow_container');
        iig = document.getElementById('documentation');

        iig.style.display = 'inherit';
        flow.style.display = 'none';

        view3State = 'iig';
      }

      window.consent_to_cookies = function () {
        document.getElementById('cookie_consent_banner').style.display = 'none';

        cookie_consent = true;
        localStorage.setItem('cookie_consent', true);

        load_from_cookies();
      }

      window.do_not_consent_to_cookies = function () {
        document.getElementById('cookie_consent_banner').style.display = 'none';

        cookie_consent = false;
        localStorage.clear();
      }

      // capture ctrl+s. doesn't do anything at the moment, but preventing a popup from appearing. but could be used to store stuff somewhere in the future.
      document.addEventListener('keydown', e => {
        if (e.ctrlKey && e.key === 's') {
          e.preventDefault();

          // well, nothing yet.
        }
      });

      require.config({ paths: { 'vs': 'monaco-editor/min/vs' } });
      require(['vs/editor/editor.main'], function () {
        code_editor = monaco.editor.create(document.getElementById('code_view'), {
          value: [
            '#include <stdlib.h>',
            '#include <stdint.h>',
            '',
            '#if defined(_MSC_VER) && !defined(__llvm__)',
            '#include <intrin.h>',
            '#else',
            '#include <x86intrin.h>',
            '#endif',
            '',
            '// what are we analyzing today? 🙂',
            '',
            'void rough_halve_line(const uint32_t *pSrcLine, const size_t length, uint32_t *pDstLine)',
            '{',
            '  const uint32_t *pSrcLine2 = pSrcLine + length;',
            '',
            '  const __m128i _7bits = _mm_set1_epi8(((uint8_t)1 << 7) - 1);',
            '  const __m128i ditherA = _mm_set1_epi64x(0x0000010001010001LL);',
            '  const __m128i ditherB = _mm_set1_epi64x(0x0101000100000100LL);',
            '',
            '  for (size_t x = 0; x < length; x += 2)',
            '  {',
            '    // where were we?',
            '    const __m128i *pLine0 = reinterpret_cast<const __m128i *>(pSrcLine + x * 2);',
            '    const __m128i *pLine1 = reinterpret_cast<const __m128i *>(pSrcLine2 + x * 2);',
            '',
            '    // load two vectors from both lines of the source.',
            '    const __m128i raw00 = _mm_loadu_si128(pLine0);',
            '    const __m128i raw01 = _mm_loadu_si128(pLine0 + 1);',
            '    const __m128i raw10 = _mm_loadu_si128(pLine1);',
            '    const __m128i raw11 = _mm_loadu_si128(pLine1 + 1);',
            '   ',
            '    // dither with saturation and divide by two.',
            '    const __m128i half00 = _mm_and_si128(_7bits, _mm_srli_epi32(_mm_adds_epu8(raw00, ditherA), 1));',
            '    const __m128i half01 = _mm_and_si128(_7bits, _mm_srli_epi32(_mm_adds_epu8(raw01, ditherB), 1));',
            '    const __m128i half10 = _mm_and_si128(_7bits, _mm_srli_epi32(_mm_adds_epu8(raw10, ditherB), 1));',
            '    const __m128i half11 = _mm_and_si128(_7bits, _mm_srli_epi32(_mm_adds_epu8(raw11, ditherA), 1));',
            '',
            '    // add lines, dither and divide by two.',
            '    const __m128i lineX0 = _mm_and_si128(_7bits, _mm_srli_epi32(_mm_adds_epu8(_mm_add_epi8(half00, half10), ditherA), 1));',
            '    const __m128i lineX1 = _mm_and_si128(_7bits, _mm_srli_epi32(_mm_adds_epu8(_mm_add_epi8(half01, half11), ditherB), 1));',
            '',
            '    // as `__m128`:',
            '    const __m128 lineX0f = _mm_castsi128_ps(lineX0);',
            '    const __m128 lineX1f = _mm_castsi128_ps(lineX1);',
            '',
            '    // shuffle the first and second color blocks into two separate vectors.',
            '    const __m128i lo = _mm_castps_si128(_mm_shuffle_ps(lineX0f, lineX1f, _MM_SHUFFLE(2, 0, 2, 0)));',
            '    const __m128i hi = _mm_castps_si128(_mm_shuffle_ps(lineX0f, lineX1f, _MM_SHUFFLE(3, 1, 3, 1)));',
            '',
            '    // add them.',
            '    const __m128i merged = _mm_add_epi8(lo, hi);',
            '',
            '    // store.',
            '    _mm_store_si128(reinterpret_cast<__m128i *>(pDstLine + x), merged);',
            '  }',
            '}',
            ''
          ].join('\n'),
          language: 'cpp',
          theme: 'vs-dark',
          automaticLayout: true,
          minimap: {
            enabled: false
          },
          padding: {
            top: "15pt"
          },
          wordWrap: 'on'
        });

        code_editor.getModel().onDidChangeContent(function (event) {
          content_changed();
        });
      });
    </script>
    <div class="h_separator"></div>
    <div id="disasm0" class="app_view disasm" style="width: 35%">
      <div class="selector">
        <select id="compiler" onchange="javascript:content_changed();">
          <optgroup label="GCC x64">
            <option value="g++-x64-11">gcc 11</option>
            <option value="g++-x64-12">gcc 12</option>
            <option value="g++-x64-13">gcc 13</option>
          </optgroup>
          <optgroup label="Clang x64">
            <option value="clang++-x64-14">clang 14</option>
            <option value="clang++-x64-15">clang 15</option>
            <option value="clang++-x64-16">clang 16</option>
            <option value="clang++-x64-17" selected="selected">clang 17</option>
          </optgroup>
        </select>
        <select id="opt_lvl" onchange="javascript:content_changed();">
          <option value="O0">-O0</option>
          <option value="O1">-O1</option>
          <option value="O2">-O2</option>
          <option value="O3">-O3</option>
          <option value="O4">-O4</option>
          <option value="Of" selected="selected">-Ofast</option>
          <option value="Os">-Os</option>
          <option value="Oz">-Oz</option>
          <option value="Og">-Og</option>
        </select>
        <select id="march" onchange="javascript:content_changed();">
          <option value="none" selected="selected">none</option>
          <optgroup label="Intel">
            <option value="sdb">Sandybridge</option> <!-- January 9, 2011 -->
            <option value="ivb">IvyBridge</option> <!-- April 29, 2012 -->
            <option value="hsw">Haswell</option> <!-- June 4, 2013 -->
            <option value="svm">Silvermont</option> <!-- Q3 2013 -->
            <option value="brw">Broadwell</option> <!-- October 27, 2014 -->
            <option value="slc">SkylakeClient</option> <!-- August 5, 2015 -->
            <option value="slx">SkylakeX</option>
            <option value="sls">SkylakeServer</option>
            <option value="gmt">Goldmont</option> <!-- Q3 2016 -->
            <option value="gmp">GoldmontPlus</option> <!-- Q4 2017 -->
            <option value="cnl">Cannonlake</option> <!-- May 15, 2018 -->
            <option value="ccl">Cascadelake</option> <!-- April 2, 2019 -->
            <option value="ilc">IcelakeClient</option> <!-- September 2019 -->
            <option value="lcs">IcelakeServer</option>
            <option value="cpl">Cooperlake</option> <!-- June 18, 2020 -->
            <option value="trm">Tremont</option> <!-- Q1 2020 -->
            <option value="tgl">Tigerlake</option> <!-- September 2, 2020 -->
            <option value="rkl">Rocketlake</option> <!-- March 30, 2021 -->
            <option value="adl">Alderlake</option> <!-- November 4, 2021 -->
            <option value="rtl">Raptorlake</option> <!-- 	October 20, 2022 -->
            <option value="spr">SapphireRapids</option> <!-- January 10, 2023 -->
            <option value="elr">EmeraldRapids</option> <!-- December 14, 2023 -->
            <option value="mtl">Meteorlake</option> <!-- TBD -->
            <option value="gtr">GraniteRapids</option> <!-- TBD -->
            <option value="gdr">GrandRidge</option> <!-- TBD -->
            <option value="srf">Sierraforest</option> <!-- TBD -->
          </optgroup>
          <optgroup label="AMD">
            <option value="zn1">Zen1</option>
            <option value="zn2">Zen2</option>
            <option value="zn3">Zen3</option>
            <option value="zn4">Zen4</option>
          </optgroup>
        </select>
        <i class="label"
          title="Instruction-Level Pseudo-Decompile Disassembly to improve readability powered by Zydec & Zydis">pseudo-decompile</i>
        <label class="switch">
          <input id="zydec" type="checkbox" checked="true" onchange="javascript:zydec_changed();">
          <span class="slider"></span>
        </label>
      </div>
      <div class="disasm_container" id="disasm_container">
        <div class="disasm" id="asm">
          Edit or Paste Code To Begin Analyzing.
        </div>
      </div>
      <div class="v_separator"></div>
      <div class="stdout" id="stdout">
        Edit or Paste Code To Begin Analyzing.
      </div>
    </div>
    <div class="h_separator"></div>
    <div class="app_view view3" id="app_view_3" style="width: 20%">
      <div class="selector">
        <div class="tab active" id="tab_flow" onclick="javascript:switch_to_flow()">
          <b class="tab_descriptor"
            title="Simulated Instruction Lane & Register Allocation powered by execution-flow & LLVM-MCA">Execution
            Flow</b>
          <select id="mca_arch" onchange="javascript:mca_changed();">
            <optgroup label="Intel">
              <option value="sdb">Sandybridge</option> <!-- January 9, 2011 -->
              <option value="ivb">IvyBridge</option> <!-- April 29, 2012 -->
              <option value="hsw">Haswell</option> <!-- June 4, 2013 -->
              <option value="svm">Silvermont</option> <!-- Q3 2013 -->
              <option value="brw">Broadwell</option> <!-- October 27, 2014 -->
              <option value="slc">SkylakeClient</option> <!-- August 5, 2015 -->
              <option value="slx">SkylakeX</option>
              <option value="sls">SkylakeServer</option>
              <option value="gmt">Goldmont</option> <!-- Q3 2016 -->
              <option value="gmp">GoldmontPlus</option> <!-- Q4 2017 -->
              <option value="cnl">Cannonlake</option> <!-- May 15, 2018 -->
              <option value="ccl">Cascadelake</option> <!-- April 2, 2019 -->
              <option value="ilc">IcelakeClient</option> <!-- September 2019 -->
              <option value="lcs">IcelakeServer</option>
              <option value="cpl">Cooperlake</option> <!-- June 18, 2020 -->
              <option value="trm">Tremont</option> <!-- Q1 2020 -->
              <option value="tgl">Tigerlake</option> <!-- September 2, 2020 -->
              <option value="rkl">Rocketlake</option> <!-- March 30, 2021 -->
              <option value="adl">Alderlake</option> <!-- November 4, 2021 -->
              <option value="rtl">Raptorlake</option> <!-- 	October 20, 2022 -->
              <option value="spr">SapphireRapids</option> <!-- January 10, 2023 -->
              <option value="elr">EmeraldRapids</option> <!-- December 14, 2023 -->
              <option value="mtl">Meteorlake</option> <!-- TBD -->
              <option value="gtr">GraniteRapids</option> <!-- TBD -->
              <option value="gdr">GrandRidge</option> <!-- TBD -->
              <option value="srf">Sierraforest</option> <!-- TBD -->
            </optgroup>
            <optgroup label="AMD">
              <option value="zn1">Zen1</option>
              <option value="zn2">Zen2</option>
              <option value="zn3">Zen3</option>
              <option value="zn4" selected="selected">Zen4</option>
              <!-- zen 5 -->
            </optgroup>
          </select>
        </div>
        <div class="tab" id="tab_iig" onclick="javascript:switch_to_iig()">
          <b class="tab_descriptor">Intel Instinsics Guide</b>
        </div>
      </div>
      <div class="view3_opt" id="execution_flow_container">
        <div id="analysis_selector" style="display: none;"></div>
        <div id="analysis" style="display: none;"></div>
        <table id="execution_flow" style="display: none;"></table>
      </div>
      <div class="view3_opt" id="documentation" style="display: none;">
        <input type="text" placeholder="Type anything to search..." id="documentation_search"
          oninput="javascript:search_iig(document.getElementById('documentation_search').value)"></input>
        <div class="iig_disclaimer">The Intel Intrinsics Guide is Courtesy of & Copyright Intel Corporation. All
          trademarks belong to their respective owners.</div>
        <div id="iig_results"></div>
        <div id="iig_spacing"></div>
      </div>
    </div>
  </div>
  <div id="cookie_consent_banner" style="display: none">
    <div class="cookie_internal">
      <h2>Hi</h2>
      <p>This website doesn't use cookies, but 'localStorage' to store your session and settings in your browser.</p>
      <p>I don't use that information to try to track you, but if you really really really want to, you can opt out of
        this feature to get a clean slate every time you open up a new tab.</p>
      <p>Your data will be sent to the server to perform the basic functions of this website (like compiling and
        analyzing your code). I believe hosting companies analyze the traffic, because that's what they do, but there's
        very little I can do about that.</p>
      <br />
      <p>Anyhow, this is a pretty small project, so if you like it or find it useful, please consider <a
          href="https://github.com/sponsors/rainerzufalldererste">supporting it on GitHub</a>. Thanks! ❤️</p>
      <br>
      <br>
      <i class="cookie_consent" onclick="javascript:consent_to_cookies()">Store my Session and use Cookie-esque
        technology</i>
      <i class="cookie_no_consent" onclick="javascript:do_not_consent_to_cookies()">Fresh slate every single time, don't
        use Cookie-esque technology</i>
    </div>
  </div>
</body>

</html>